/* IMPORT */
import { SCOPE_ALL } from '../constants.js';
import Lang from '../utils/lang.js';
import Parser from '../utils/parser.js';
import PathProp from '../utils/pp.js';
/* MAIN */
class ProviderAbstract {
    /* CONSTRUCTOR */
    constructor(options) {
        this.filter = Lang.identity;
        if (options.scope === SCOPE_ALL)
            throw new Error(`"${SCOPE_ALL}" is not a valid scope name for a provider`);
        // if ( options.scope === SCOPE_DEFAULTS ) throw new Error ( `"${SCOPE_DEFAULTS}" is not a valid scope name for a provider` ); //TODO: Account for the "defaults" scope created internally rather than externally
        this.scope = options.scope;
        this.dataParser = options.parser ?? new Parser(options?.indentation ?? '\t');
        this.defaultsRaw = options.defaultsRaw ?? '{\n\t\n}';
        this.defaults = PathProp.unflat(options.defaults ?? (this.dataParser.parse(this.defaultsRaw) || {}));
        this.handlers = [];
        this.init();
    }
    /* PROTECTED API */
    init() {
        const { data, dataRaw } = this.readSync();
        this.data = data;
        this.dataRaw = dataRaw;
        this.dataFiltered = this.filter(this.data);
    }
    isEqual(data) {
        return Lang.isString(data) ? data === this.dataRaw : Lang.isEqual(data, this.data);
    }
    trigger() {
        for (const handler of this.handlers) {
            handler();
        }
    }
    /* PUBLIC API */
    dispose() {
        return;
    }
    onChange(handler) {
        this.handlers.push(handler);
        return () => {
            this.handlers.splice(this.handlers.indexOf(handler), 1);
        };
    }
}
/* EXPORT */
export default ProviderAbstract;
