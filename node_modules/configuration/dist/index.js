/* IMPORT */
import { SCOPE_ALL, SCOPE_DEFAULTS } from './constants.js';
import ProviderMemory from './providers/memory.js';
import Lang from './utils/lang.js';
import PathProp from './utils/pp.js';
/* MAIN */
//TODO: Somehow preserve comments in `dataRaw` when editing `data` via the APIs (edit `dataRaw` directly when possible)
class Configuration {
    /* CONSTRUCTOR */
    constructor(options) {
        if (!options.providers.length)
            throw new Error('You need to provide at least one configuration provider');
        this.providers = options.providers;
        this.scopes = {};
        this.isArray = Lang.isArray(options.defaults);
        this.defaults = new ProviderMemory({ scope: SCOPE_DEFAULTS });
        this.defaults.writeSync(options.defaults, true);
        this.data = options.defaults.constructor();
        this.filter = value => options.filter?.(value) ?? value;
        this.handlers = [];
        this.init();
    }
    /* HELPERS */
    getDefaultScope() {
        return this.providers[this.providers.length - 2]?.scope; //UGLY
    }
    getTargetScopeForPath(path) {
        for (let i = 0, l = this.providers.length - 1; i < l; i++) {
            const { scope } = this.providers[i];
            if (this.has(scope, path))
                return scope;
        }
        return this.getDefaultScope();
    }
    /* PRIVATE API */
    init() {
        this.providers.push(this.defaults);
        for (const provider of this.providers) {
            provider.filter = this.filter;
            provider.dataFiltered = provider.filter(provider.data);
            provider.onChange(this.refresh.bind(this));
            this.scopes[provider.scope] = provider;
        }
        this.refresh();
    }
    refresh() {
        const datas = this.providers.map(provider => provider.dataFiltered).reverse();
        const datasFiltered = datas.filter(data => Lang.isArray(data) === this.isArray);
        this.data = this.isArray ? datasFiltered.flat() : Lang.merge(datasFiltered);
        this.trigger();
    }
    trigger() {
        for (const data of this.handlers) {
            const value = data.getter();
            if ((Lang.isUndefined(data.value) || !Lang.isPrimitive(data.value)) && !Lang.isPrimitive(value) && Lang.isNullary(data.callback)) { //TODO: This is not exactly correct, something might have been changed while the flattened configuration could still be the same, but this is much faster
                data.callback();
                data.value = value;
            }
            else if (!Lang.isEqual(data.value, value)) {
                const valueNext = Lang.cloneDeep(value);
                data.callback(valueNext, data.value);
                data.value = valueNext;
            }
        }
    }
    /* PUBLIC API */
    dispose() {
        for (const provider of this.providers) {
            provider.dispose();
        }
    }
    get(scope, path) {
        if (Lang.isUndefined(scope)) { // Data
            return this.data;
        }
        else if (scope === SCOPE_ALL) { // All
            const scopes = {};
            for (const scope in this.scopes) {
                scopes[scope] = Lang.isUndefined(path) ? this.scopes[scope].dataFiltered : PathProp.get(this.scopes[scope].dataFiltered, path);
            }
            return scopes;
        }
        else if (Lang.isUndefined(path)) { // Path
            return PathProp.get(this.data, scope);
        }
        else { // Scope + Path
            const provider = this.scopes[scope];
            if (!provider)
                throw new Error('You cannot get from unknown scopes');
            return PathProp.get(provider.dataFiltered, path);
        }
    }
    has(scope, path) {
        if (scope === SCOPE_ALL) { // All
            const scopes = {};
            for (const scope in this.scopes) {
                scopes[scope] = Lang.isUndefined(path) ? !!this.scopes[scope].dataFiltered : PathProp.has(this.scopes[scope].dataFiltered, path);
            }
            return scopes;
        }
        else if (Lang.isUndefined(path)) { // Path
            return PathProp.has(this.data, scope);
        }
        else { // Scope + Path
            const provider = this.scopes[scope];
            if (!provider)
                throw new Error('You cannot check unknown scopes');
            return PathProp.has(provider.dataFiltered, path);
        }
    }
    remove(scope, path) {
        if (Lang.isUndefined(path)) { // Path
            return this.remove(SCOPE_ALL, scope);
        }
        else if (scope === SCOPE_ALL) { // All
            for (const scope in this.scopes) {
                if (scope === SCOPE_DEFAULTS)
                    continue;
                const provider = this.scopes[scope];
                if (!PathProp.has(provider.data, path))
                    continue;
                PathProp.remove(provider.data, path);
                provider.write(provider.data, true);
            }
        }
        else { // Scope + Path
            if (scope === SCOPE_DEFAULTS)
                throw new Error('You cannot delete in the "defaults" scope');
            const provider = this.scopes[scope];
            if (!provider)
                throw new Error('You cannot remove from unknown scopes');
            if (!PathProp.has(provider.data, path))
                return;
            PathProp.remove(provider.data, path);
            provider.write(provider.data, true);
        }
    }
    reset(scope = SCOPE_ALL) {
        if (scope === SCOPE_ALL) { // All
            for (const scope in this.scopes) {
                if (scope === SCOPE_DEFAULTS)
                    continue;
                this.scopes[scope].write(this.scopes[scope].defaultsRaw);
            }
        }
        else { // Scope
            if (scope === SCOPE_DEFAULTS)
                throw new Error('You cannot reset the "defaults" scope');
            const provider = this.scopes[scope];
            if (!provider)
                throw new Error('You cannot reset unknown scopes');
            provider.write(provider.defaultsRaw);
        }
    }
    scope(scope) {
        return this.scopes[scope];
    }
    set(scope, path, value) {
        if (Lang.isUndefined(value)) { // Path
            const targetScope = this.getTargetScopeForPath(scope);
            if (!targetScope)
                throw new Error('You cannot set without any providers');
            return this.set(targetScope, scope, path);
        }
        if (!Lang.isString(path))
            return; //TSC
        if (scope === SCOPE_ALL) { // All
            for (const scope in this.scopes) {
                if (scope === SCOPE_DEFAULTS)
                    continue;
                const provider = this.scopes[scope];
                if (Lang.isEqual(PathProp.get(provider.data, path), value))
                    continue;
                PathProp.set(provider.data, path, value);
                provider.write(provider.data, true);
            }
        }
        else { // Scope + Path
            if (scope === SCOPE_DEFAULTS)
                throw new Error('You cannot set in the "defaults" scope');
            const provider = this.scopes[scope];
            if (!provider)
                throw new Error('You cannot set in unknown scopes');
            if (Lang.isEqual(PathProp.get(provider.data, path), value))
                return;
            PathProp.set(provider.data, path, value);
            provider.write(provider.data, true);
        }
    }
    update(scope, data) {
        if (Lang.isUndefined(data)) { // Data
            const targetScope = this.getDefaultScope();
            if (!targetScope)
                throw new Error('You cannot update without any providers');
            return this.update(targetScope, scope);
        }
        if (!Lang.isString(scope))
            return; //TSC
        if (scope === SCOPE_ALL) { // All
            for (const scope in this.scopes) {
                if (scope === SCOPE_DEFAULTS)
                    continue;
                this.scopes[scope].write(data);
            }
        }
        else { // Scope + Path
            if (scope === SCOPE_DEFAULTS)
                throw new Error('You cannot update in the "defaults" scope');
            const provider = this.scopes[scope];
            if (!provider)
                throw new Error('You cannot update unknown scopes');
            provider.write(data);
        }
    }
    onChange(scope, path, handler) {
        const { handlers } = this;
        const args = arguments;
        const getterArgs = Array.prototype.slice.call(args, 0, -1);
        const callback = args[args.length - 1];
        const getter = () => this.get(...getterArgs);
        const valueRaw = getter();
        const value = Lang.isPrimitive(valueRaw) || !Lang.isNullary(callback) ? Lang.cloneDeep(valueRaw) : undefined;
        const data = { callback, getter, value };
        handlers.push(data);
        return () => {
            handlers.splice(handlers.indexOf(data), 1);
        };
    }
}
/* EXPORT */
export default Configuration;
